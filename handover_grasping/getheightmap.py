# AUTOGENERATED! DO NOT EDIT! File to edit: 03_getheightmap.ipynb (unless otherwise specified).

__all__ = ['bwareaopen', 'bg_subtraction', 'project_depth2camera', 'points2world', 'getgridmapping',
           'getheightmapColor', 'heightmapwithbgsubtraction', 'FixMissingDepth2camera', 'getMissingdepthheightmap',
           'denoiseheightmap']

# Cell
import cv2
import numpy as np
import imageio

def bwareaopen(image, sz):
    output = image.copy()
    nlabels, labels, stats, centroids = cv2.connectedComponentsWithStats(image)
    for i in range(1,nlabels-1):
        regions_size = stats[i,4]
        if regions_size < sz:
            x0 = stats[i,0]
            y0 = stats[i,1]
            x1 = stats[i,0]+stats[i,2]
            y1 = stats[i,1]+stats[i,3]
            for row in range(y0, y1):
                for col in range(x0, x1):
                    if labels[row, col] == i:
                        output[row, col] = 0

    return output

def bg_subtraction(colorIMg, bgColorImg, depthImg, bgDepthImg):
    tmp = abs(colorIMg - bgColorImg)
    tmp[tmp<0.3] == 1

    fgMaskColor = np.sum(tmp,2)
    fgMaskColor[fgMaskColor!=3] = 1
    fgMaskColor[fgMaskColor==3] = 0

    tmp = abs(depthImg-bgDepthImg)
    tmp[tmp>0.02] = 1
    tmp[tmp!=1] = 0

    bgDepthImg[bgDepthImg!=0] = 1

    fgMaskDepth = np.zeros(bgDepthImg.shape)
    fgMaskDepth[((tmp == 1) & (bgDepthImg == 1))] = 1

    fgMask = np.ones(bgDepthImg.shape)
    fgMask[((fgMaskDepth == 0) & (fgMaskColor == 0))] = 0

    return fgMaskColor, fgMask

def project_depth2camera(camIntrinsics, camPose, depthImg):
    xvalues = np.linspace(1,640,640)
    yvalues = np.linspace(1,480,480)
    pixX,pixY = np.meshgrid(xvalues, yvalues)

    camX = (pixX - camIntrinsics[0][2])*(depthImg/camIntrinsics[0][0])
    camY = (pixY - camIntrinsics[1][2])*(depthImg/camIntrinsics[1][1])
    camZ = depthImg
    camPts = np.array([camX.flatten('F').transpose(),camY.flatten('F').transpose(), camZ.flatten('F').transpose()])
    camPts = camPts.transpose()

    return camPts

def points2world(camPose, camPts):
    g = np.expand_dims(camPose[0:3,3], axis=1)
    tmp = np.repeat(g,307200, axis=1).transpose()
    tmp2 = np.dot(camPose[0:3,0:3], camPts.transpose()).transpose()
    worldPts = tmp2 + tmp

    return worldPts

def getgridmapping(worldPts, binMiddleBottom):
    voxelSize = 0.002
    gridOrigin = [binMiddleBottom[0][0]-0.3,binMiddleBottom[0][1]-0.2,binMiddleBottom[0][2]]
    gridMapping_1 = np.around((worldPts[:,0] - gridOrigin[0])/voxelSize)
    gridMapping_2 = np.around((worldPts[:,1] - gridOrigin[1])/voxelSize)
    gridMapping_3 = (worldPts[:,2] - binMiddleBottom[0][2])
    gridMapping = np.array([gridMapping_1, gridMapping_2, gridMapping_3]).transpose()

    return gridMapping

def getheightmapColor(gridMapping, colorIMg):
    heightMap = np.zeros((200,300))
    heightMapColor = np.zeros((200*300,3))

    Tmp0 = np.zeros(gridMapping[:,0].shape)
    Tmp0[gridMapping[:,0]>0] = 1

    Tmp1 = np.zeros(gridMapping[:,0].shape)
    Tmp1[gridMapping[:,0]<= 300] = 1

    Tmp2 = np.zeros(gridMapping[:,1].shape)
    Tmp2[gridMapping[:,1] > 0] = 1

    Tmp3 = np.zeros(gridMapping[:,1].shape)
    Tmp3[gridMapping[:,1]<=200] = 1

    colorPts = np.array([colorIMg[:,:,0].flatten('F'), colorIMg[:,:,1].flatten('F'), colorIMg[:,:,2].flatten('F')]).transpose()
    validPix = np.zeros(gridMapping[:,0].shape)

    tmp = []
    tmp2 = []
    tmp3 = [[],[],[]]

    for i in range(validPix.shape[0]):
        if Tmp0[i] == 1 and Tmp1[i] == 1 and Tmp2[i] == 1 and Tmp3[i] == 1:
            validPix[i] = 1
            tmp.append(int(gridMapping[i,1])-1)
            tmp2.append(int(gridMapping[i,0])-1)
            tmp3[0].append(colorPts[i,0])
            tmp3[1].append(colorPts[i,1])
            tmp3[2].append(colorPts[i,2])

    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = np.array(tmp3).transpose()

    for i in range(s.shape[0]):
        heightMapColor[s[i], :] = tmp3[i,:]

    return heightMapColor

def heightmapwithbgsubtraction(gridMapping, fgMask, depthImg):
    heightMap = np.zeros((200,300))
    tmp0 = np.zeros(gridMapping[:,0].shape)
    tmp0[gridMapping[:,0]>0] = 1

    tmp1 = np.zeros(gridMapping[:,0].shape)
    tmp1[gridMapping[:,0]<=300] = 1

    tmp2 = np.zeros(gridMapping[:,1].shape)
    tmp2[gridMapping[:,1]>0] = 1

    tmp3 = np.zeros(gridMapping[:,1].shape)
    tmp3[gridMapping[:,1]<=200] = 1

    tmp4 = np.zeros(gridMapping[:,2].shape)
    tmp4[gridMapping[:,2]>0] = 1

    validPix = np.zeros(gridMapping[:,0].shape)
    validPix[((tmp0 == 1) & (tmp1 == 1) & (tmp2 == 1) & (tmp3 == 1) & (tmp4 == 1))] = 1

    validDepth = np.zeros(fgMask.shape)
    validDepth[((fgMask != 0) & (depthImg != 0))] = 1

    tmp = validDepth.flatten('F')
    tmp3 = [[],[],[]]
    for i in range(validPix.shape[0]):
        if validPix[i] != 0 and tmp[i]!= 0:
            tmp3[0].append(gridMapping[i,0])
            tmp3[1].append(gridMapping[i,1])
            tmp3[2].append(gridMapping[i,2])
    gridMapping = np.array(tmp3).transpose()

    tmp = []
    tmp2 = []
    for i in range(gridMapping.shape[0]):
        tmp.append(int(gridMapping[i,1])-1)
        tmp2.append(int(gridMapping[i,0])-1)

    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = []
    for i in range(gridMapping[:,2].shape[0]):
        tmp3.append(gridMapping[:,2][i])

    for i in range(s.shape[0]):
        coord = np.unravel_index(s[i], (200,300), order='F')
        heightMap[coord[0],coord[1]] = tmp3[i]

    return heightMap

def FixMissingDepth2camera(depthImg, bgDepthImg, camIntrinsics, camPose):
    missingDepth = np.zeros(depthImg.shape)
    missingDepth[((depthImg) == 0 & (bgDepthImg > 0))] = 1

    xvalues = np.linspace(1,640,640)
    yvalues = np.linspace(1,480,480)
    pixX,pixY = np.meshgrid(xvalues, yvalues)

    camX = (pixX - camIntrinsics[0][2])*(bgDepthImg/camIntrinsics[0][0])
    camY = (pixY - camIntrinsics[1][2])*(bgDepthImg/camIntrinsics[1][1])
    camZ = bgDepthImg

    tmp = [[],[],[]]
    for i in range(missingDepth.shape[1]):
        for j in range(missingDepth.shape[0]):
            if missingDepth[j, i] == 1:
                tmp[0].append(camX[j, i])
                tmp[1].append(camY[j, i])
                tmp[2].append(camZ[j, i])

    missingCamPts = np.array(tmp).transpose()

    g = np.expand_dims(camPose[0:3,3], axis=1)
    tmp = np.repeat(g,missingCamPts.shape[0], axis=1).transpose()
    tmp2 = np.dot(camPose[0:3,0:3], missingCamPts.transpose()).transpose()
    missingCamPtsworldPts = tmp2 + tmp

    return missingDepth, missingCamPts, missingCamPtsworldPts

def getMissingdepthheightmap(binMiddleBottom, missingCamPtsworldPts):
    voxelSize = 0.002
    missingHeightMap = np.zeros((200,300))
    gridOrigin = [binMiddleBottom[0][0]-0.3,binMiddleBottom[0][1]-0.2,binMiddleBottom[0][2]]
    gridMapping_1 = np.around((missingCamPtsworldPts[:,0] - gridOrigin[0])/voxelSize)
    gridMapping_2 = np.around((missingCamPtsworldPts[:,1] - gridOrigin[1])/voxelSize)
    gridMapping_3 = (missingCamPtsworldPts[:,2] - binMiddleBottom[0][2])
    gridMapping = np.array([gridMapping_1, gridMapping_2, gridMapping_3]).transpose()

    tmp0 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp0.shape[0]):
        if gridMapping[i,0] > 0:
            tmp0[i] = 1

    tmp1 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp1.shape[0]):
        if gridMapping[i,0] <= 300:
            tmp1[i] = 1

    tmp2 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp2.shape[0]):
        if gridMapping[i,1] > 0:
            tmp2[i] = 1

    tmp3 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp3.shape[0]):
        if gridMapping[i,1] <=200:
            tmp3[i] = 1

    tmp = [[],[],[]]
    validPix = np.zeros(gridMapping[:,0].shape)
    for i in range(validPix.shape[0]):
        if tmp0[i] == 1 and tmp1[i] == 1 and tmp2[i] == 1 and tmp3[i] == 1:
            validPix[i] = 1
            tmp[0].append(gridMapping[i,0])
            tmp[1].append(gridMapping[i,1])
            tmp[2].append(gridMapping[i,2])

    gridMapping = np.array(tmp).transpose()

    tmp = []
    tmp2 = []
    for i in range(gridMapping.shape[0]):
        tmp.append(int(gridMapping[i,1])-1)
        tmp2.append(int(gridMapping[i,0])-1)

    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = []
    for i in range(gridMapping[:,2].shape[0]):
        tmp3.append(gridMapping[:,2][i])

    for i in range(s.shape[0]):
        coord = np.unravel_index(s[i], (200,300), order='F')
        missingHeightMap[coord[0],coord[1]] = 1


    missingHeightMap = missingHeightMap.astype('uint8')
    g = np.zeros(missingHeightMap.shape).astype('uint8')
    g[missingHeightMap > 0] = 1
    tmp = bwareaopen(g, 50)
    L = np.ones(missingHeightMap.shape).astype('uint8')
    noisePix = L - tmp
    missingHeightMap[noisePix==1] = 0

    return missingHeightMap, noisePix

def denoiseheightmap(heightMap, noisePix):
    heightMap = heightMap.astype('uint8')
    g = np.zeros(heightMap.shape).astype('uint8')
    g[heightMap > 0] = 1
    tmp = bwareaopen(g, 50)
    L = np.ones(heightMap.shape).astype('uint8')
    noisePix = L - tmp
    heightMap[noisePix==1] = 0

    return heightMap