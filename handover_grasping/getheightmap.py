# AUTOGENERATED! DO NOT EDIT! File to edit: getheightmap.ipynb (unless otherwise specified).

__all__ = ['bwareaopen', 'bg_subtraction', 'project_depth2camera', 'points2world', 'getgridmapping',
           'getheightmapColor', 'heightmapwithbgsubtraction', 'FixMissingDepth2camera', 'getMissingdepthheightmap',
           'denoiseheightmap']

# Cell
import cv2
import numpy as np
import imageio

def bwareaopen(image, sz):
    output = image.copy()
    nlabels, labels, stats, centroids = cv2.connectedComponentsWithStats(image)
    for i in range(1,nlabels-1):
        regions_size = stats[i,4]
        if regions_size < sz:
            x0 = stats[i,0]
            y0 = stats[i,1]
            x1 = stats[i,0]+stats[i,2]
            y1 = stats[i,1]+stats[i,3]
            for row in range(y0, y1):
                for col in range(x0, x1):
                    if labels[row, col] == i:
                        output[row, col] = 0

    return output

def bg_subtraction(colorIMg, bgColorImg, depthImg, bgDepthImg):
    tmp = abs(colorIMg - bgColorImg)
    for i in range(tmp.shape[0]):
        for j in range(tmp.shape[1]):
            for k in range(3):
                if tmp[i,j,k] < 0.3:
                    tmp[i,j,k] = 1
                else:
                    tmp[i,j,k] = 0

    fgMaskColor = np.sum(tmp,2)
    fgMaskColor[fgMaskColor!=3] = 1
    fgMaskColor[fgMaskColor==3] = 0

    tmp = abs(depthImg-bgDepthImg)
    for i in range(tmp.shape[0]):
        for j in range(tmp.shape[1]):
            if tmp[i,j] > 0.02:
                tmp[i,j] = 1
            else:
                tmp[i,j] = 0
            if bgDepthImg[i,j] == 0:
                bgDepthImg[i,j] = 0
            else:
                bgDepthImg[i,j] = 1

    fgMaskDepth = np.zeros(bgDepthImg.shape)
    for i in range(fgMaskDepth.shape[0]):
        for j in range(fgMaskDepth.shape[1]):
            if tmp[i,j] == 1 and bgDepthImg[i,j] == 1:
                fgMaskDepth[i,j] = 1
            else:
                fgMaskDepth[i,j] = 0

    fgMask = np.zeros(bgDepthImg.shape)
    for i in range(fgMaskDepth.shape[0]):
        for j in range(fgMaskDepth.shape[1]):
            if fgMaskDepth[i,j] == 0 and fgMaskColor[i,j] == 0:
                fgMask[i,j] = 0
            else:
                fgMask[i,j] = 1

    return fgMaskColor, fgMask

def project_depth2camera(camIntrinsics, camPose, depthImg):
    xvalues = np.linspace(1,640,640)
    yvalues = np.linspace(1,480,480)
    pixX,pixY = np.meshgrid(xvalues, yvalues)

    camX = (pixX - camIntrinsics[0][2])*(depthImg/camIntrinsics[0][0])
    camY = (pixY - camIntrinsics[1][2])*(depthImg/camIntrinsics[1][1])
    camZ = depthImg
    camPts = np.array([camX.flatten('F').transpose(),camY.flatten('F').transpose(), camZ.flatten('F').transpose()])
    camPts = camPts.transpose()

    return camPts

def points2world(camPose, camPts):
    g = np.expand_dims(camPose[0:3,3], axis=1)
    tmp = np.repeat(g,307200, axis=1).transpose()
    tmp2 = np.dot(camPose[0:3,0:3], camPts.transpose()).transpose()
    worldPts = tmp2 + tmp

    return worldPts

def getgridmapping(worldPts, binMiddleBottom):
    voxelSize = 0.002
    gridOrigin = [binMiddleBottom[0][0]-0.3,binMiddleBottom[0][1]-0.2,binMiddleBottom[0][2]]
    gridMapping_1 = np.around((worldPts[:,0] - gridOrigin[0])/voxelSize)
    gridMapping_2 = np.around((worldPts[:,1] - gridOrigin[1])/voxelSize)
    gridMapping_3 = (worldPts[:,2] - binMiddleBottom[0][2])
    gridMapping = np.array([gridMapping_1, gridMapping_2, gridMapping_3]).transpose()

    return gridMapping

def getheightmapColor(gridMapping, colorIMg):
    heightMap = np.zeros((200,300))
    heightMapColor = np.zeros((200*300,3))
    tmp0 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp0.shape[0]):
        if gridMapping[i,0] > 0:
            tmp0[i] = 1

    tmp1 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp1.shape[0]):
        if gridMapping[i,0] <= 300:
            tmp1[i] = 1

    tmp2 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp2.shape[0]):
        if gridMapping[i,1] > 0:
            tmp2[i] = 1

    tmp3 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp3.shape[0]):
        if gridMapping[i,1] <=200:
            tmp3[i] = 1

    validPix = np.zeros(gridMapping[:,0].shape)
    for i in range(validPix.shape[0]):
        if tmp0[i] == 1 and tmp1[i] == 1 and tmp2[i] == 1 and tmp3[i] == 1:
            validPix[i] = 1

    colorPts = np.array([colorIMg[:,:,0].flatten('F'), colorIMg[:,:,1].flatten('F'), colorIMg[:,:,2].flatten('F')]).transpose()

    tmp = []
    tmp2 = []
    for i in range(validPix.shape[0]):
        if validPix[i] == 1:
            tmp.append(int(gridMapping[i,1])-1)
            tmp2.append(int(gridMapping[i,0])-1)


    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = [[],[],[]]
    for i in range(validPix.shape[0]):
        if validPix[i] == 1:
            tmp3[0].append(colorPts[i,0])
            tmp3[1].append(colorPts[i,1])
            tmp3[2].append(colorPts[i,2])
    tmp3 = np.array(tmp3).transpose()

    for i in range(s.shape[0]):
        heightMapColor[s[i], :] = tmp3[i,:]

    return heightMapColor

def heightmapwithbgsubtraction(gridMapping, fgMask, depthImg):
    heightMap = np.zeros((200,300))
    tmp0 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp0.shape[0]):
        if gridMapping[i,0] > 0:
            tmp0[i] = 1

    tmp1 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp1.shape[0]):
        if gridMapping[i,0] <= 300:
            tmp1[i] = 1

    tmp2 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp2.shape[0]):
        if gridMapping[i,1] > 0:
            tmp2[i] = 1

    tmp3 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp3.shape[0]):
        if gridMapping[i,1] <=200:
            tmp3[i] = 1

    tmp4 = np.zeros(gridMapping[:,2].shape)
    for i in range(tmp4.shape[0]):
        if gridMapping[i,2] > 0:
            tmp4[i] = 1

    validPix = np.zeros(gridMapping[:,0].shape)
    for i in range(validPix.shape[0]):
        if tmp0[i] == 1 and tmp1[i] == 1 and tmp2[i] == 1 and tmp3[i] == 1 and tmp4[i] == 1:
            validPix[i] = 1

    validDepth = np.zeros(fgMask.shape)
    for i in range(validDepth.shape[0]):
        for j in range(validDepth.shape[1]):
            if fgMask[i,j] != 0 and depthImg[i,j]!= 0:
                validDepth[i,j] = 1

    tmp = validDepth.flatten('F')
    tmp3 = [[],[],[]]
    for i in range(validPix.shape[0]):
        if validPix[i] != 0 and tmp[i]!= 0:
            tmp3[0].append(gridMapping[i,0])
            tmp3[1].append(gridMapping[i,1])
            tmp3[2].append(gridMapping[i,2])
    gridMapping = np.array(tmp3).transpose()

    tmp = []
    tmp2 = []
    for i in range(gridMapping.shape[0]):
        tmp.append(int(gridMapping[i,1])-1)
        tmp2.append(int(gridMapping[i,0])-1)

    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = []
    for i in range(gridMapping[:,2].shape[0]):
        tmp3.append(gridMapping[:,2][i])

    for i in range(s.shape[0]):
        coord = np.unravel_index(s[i], (200,300), order='F')
        heightMap[coord[0],coord[1]] = tmp3[i]

    return heightMap

def FixMissingDepth2camera(depthImg, bgDepthImg, camIntrinsics, camPose):
    missingDepth = np.zeros(depthImg.shape)
    for i in range(missingDepth.shape[0]):
        for j in range(missingDepth.shape[1]):
            if depthImg[i,j] == 0 and bgDepthImg[i,j] > 0:
                missingDepth[i,j] = 1

    xvalues = np.linspace(1,640,640)
    yvalues = np.linspace(1,480,480)
    pixX,pixY = np.meshgrid(xvalues, yvalues)

    camX = (pixX - camIntrinsics[0][2])*(bgDepthImg/camIntrinsics[0][0])
    camY = (pixY - camIntrinsics[1][2])*(bgDepthImg/camIntrinsics[1][1])
    camZ = bgDepthImg

    tmp = [[],[],[]]
    for i in range(missingDepth.shape[1]):
        for j in range(missingDepth.shape[0]):
            if missingDepth[j, i] == 1:
                tmp[0].append(camX[j, i])
                tmp[1].append(camY[j, i])
                tmp[2].append(camZ[j, i])

    missingCamPts = np.array(tmp).transpose()

    g = np.expand_dims(camPose[0:3,3], axis=1)
    tmp = np.repeat(g,missingCamPts.shape[0], axis=1).transpose()
    tmp2 = np.dot(camPose[0:3,0:3], missingCamPts.transpose()).transpose()
    missingCamPtsworldPts = tmp2 + tmp

    return missingDepth, missingCamPts, missingCamPtsworldPts

def getMissingdepthheightmap(binMiddleBottom, missingCamPtsworldPts):
    voxelSize = 0.002
    missingHeightMap = np.zeros((200,300))
    gridOrigin = [binMiddleBottom[0][0]-0.3,binMiddleBottom[0][1]-0.2,binMiddleBottom[0][2]]
    gridMapping_1 = np.around((missingCamPtsworldPts[:,0] - gridOrigin[0])/voxelSize)
    gridMapping_2 = np.around((missingCamPtsworldPts[:,1] - gridOrigin[1])/voxelSize)
    gridMapping_3 = (missingCamPtsworldPts[:,2] - binMiddleBottom[0][2])
    gridMapping = np.array([gridMapping_1, gridMapping_2, gridMapping_3]).transpose()

    tmp0 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp0.shape[0]):
        if gridMapping[i,0] > 0:
            tmp0[i] = 1

    tmp1 = np.zeros(gridMapping[:,0].shape)
    for i in range(tmp1.shape[0]):
        if gridMapping[i,0] <= 300:
            tmp1[i] = 1

    tmp2 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp2.shape[0]):
        if gridMapping[i,1] > 0:
            tmp2[i] = 1

    tmp3 = np.zeros(gridMapping[:,1].shape)
    for i in range(tmp3.shape[0]):
        if gridMapping[i,1] <=200:
            tmp3[i] = 1

    tmp = [[],[],[]]
    validPix = np.zeros(gridMapping[:,0].shape)
    for i in range(validPix.shape[0]):
        if tmp0[i] == 1 and tmp1[i] == 1 and tmp2[i] == 1 and tmp3[i] == 1:
            validPix[i] = 1
            tmp[0].append(gridMapping[i,0])
            tmp[1].append(gridMapping[i,1])
            tmp[2].append(gridMapping[i,2])

    gridMapping = np.array(tmp).transpose()

    tmp = []
    tmp2 = []
    for i in range(gridMapping.shape[0]):
        tmp.append(int(gridMapping[i,1])-1)
        tmp2.append(int(gridMapping[i,0])-1)

    tmp = np.array(tmp)
    tmp2 = np.array(tmp2)
    arr = np.array([tmp, tmp2])
    s = np.ravel_multi_index(arr, (200,300), order='F')
    tmp3 = []
    for i in range(gridMapping[:,2].shape[0]):
        tmp3.append(gridMapping[:,2][i])

    for i in range(s.shape[0]):
        coord = np.unravel_index(s[i], (200,300), order='F')
        missingHeightMap[coord[0],coord[1]] = 1


    missingHeightMap = missingHeightMap.astype('uint8')
    g = np.zeros(missingHeightMap.shape).astype('uint8')
    g[missingHeightMap > 0] = 1
    tmp = bwareaopen(g, 50)
    L = np.ones(missingHeightMap.shape).astype('uint8')
    noisePix = L - tmp
    missingHeightMap[noisePix==1] = 0

    return missingHeightMap, noisePix

def denoiseheightmap(heightMap, noisePix):
    heightMap = heightMap.astype('uint8')
    g = np.zeros(heightMap.shape).astype('uint8')
    g[heightMap > 0] = 1
    tmp = bwareaopen(g, 50)
    L = np.ones(heightMap.shape).astype('uint8')
    noisePix = L - tmp
    heightMap[noisePix==1] = 0

    return heightMap